## 🎯 목표
### 자바의 Class 와 Interface에 대해 학습하기.

### 📌 학습할 것
### [클래스](#-클래스)
- [클래스 정의](#-클래스-정의)
- [클래스 구성](#-클래스-구성)
- [클래스 작성](#-클래스-작성)
- [new 키워드](#-new-키워드)
- [this 키워드](#-this-키워드)
- [super 키워드](#-super-키워드)

### [추상 클래스](#추상-클래스)

### [인터페이스](#-인터페이스)
- [인터페이스 정의](#-인터페이스-정의)
- [인터페이스 구현](#-인터페이스-구현)

--- 

## 🇨🇱 클래스
### 💡 클래스 정의

자바에서 클래스란 유사한 특징들의 지닌 객체들의 속성과 행위들을 정의해놓은 설계도와 같은 것이다.<br>
이 설계도를 이용해서 동일한 특징을 객체를 찍어내는 틀과 같은 역할을 한다.

**객체** : 실세계(Real World)에 존재하는 유/무형의 **모든 것**

속성(명사형)과 행위(동사형)를 갖는다.

ex) **자동차** (유형)

- 속성 : 주행거리, 차종, 색상, 마력,,, 
- 행위 : 시동켜기, 시동끄기, 주행하기,,, 
    
ex) **계좌** (무형)

- 속성 : 계좌번호, 예금주, 잔액, 이체한도,,,
- 행위 : 잔액조회, 입금, 출금, 송금,,, 

|클래스|객체|
|:-:|:-:|
|붕어빵틀|붕어빵|
|공장 생산라인|제품|
|건물설계도|건물|

같은 클래스로부터 생성된 객체는 모두 같은 속성과 행위를 가지는데, 객체마다 고유한 속성값을 가질 수 있다.

**즉, 같은 클래스에서 생성된 객체라도 모두 다르다!**

---

클래스는 접근제어자와 함께 class키워드를 사용해서 정의할 수 있다.

```java
[접근 제어자] class XXX{
    필드
    생성자
    메소드
}
```

만약 public class로 클래스를 정의하면 해당 소스코드(.java)의 이름은 반드시 해당 클래스의 이름으로 작성되어야 한다.

> ex) public class Baemung ==> Baemung.java

그리고 클래스를 정의할 땐, 클래스 이름 첫글자는 보통 대문자로 시작하는 파스칼 표기법(PascalCase) 를 사용한다.

클래스안에 다른 클래스를 정의하는 것도 가능하다. <br>
이렇게 하나의 클래스 파일에 여러 클래스를 정의했을 때 [소스코드를 컴파일하면 각 클래스마다 .class 파일이 생성되는 것을 확인할 수 있다.](../../../tree/main/Week_01/#-컴파일-및-실행하는-방법)

클래스를 정의할 때 객체들의 속성과 행위를 필드와 메소드로 정의할 수 있다.

|객체|클래스|
|:-:|:-:|
|속성|필드 (클래스변수(static), 인스턴스변수(non-static))|
|행위|메소드|

- 사람 (객체)
   - 속성 : 이름, 나이
   - 행위 : 나이먹기, 잠자기,,,


- Person (클래스)

> Person.java

```java
public class Person{
    //field
    String name;
    int age;
    
    //constructor
    Person(String name, int age){
        this.name = name;
        this.age = age;
    }
    
    //method
    increaseAge(){}
    Sleep(){}
}
```

### 💡 클래스 구성

#### 1. [**필드(field)**](../../../tree/main/Week_02/#-변수의-스코프와-라이프타임)

클래스의 필드(field)란 클래스에 포함된 멤버 변수(variable)

- **클래스 변수(static variable)**
    - 클래스의 상태
    - 클래스 메모리 로드시 1번만 할당
    
- **인스턴스 변수(instance variable)**
    - 객체의 상태
    - 객체 생성시마다 할당

#### 2. **메소드(method)**

클래스에서 메소드(method)란 어떠한 특정 작업을 수행하기 위한 명령문의 집합

- **클래스 메소드(static method)**
    - 클래스 관점에서의 행위
    - 객체 식별을 해야만하는 작업X
    - 객체를 생성하지 않고도 실행할 수 있는 작업
    
- **인스턴스 메소드(instance method)**
    - 객체 관점에서의 행위
    - 객체 식별을 해야만 하는 작업 O
    - 객체 관련 작업

#### 3. **생성자(constructor)**

클래스를 생성할 때, 필드(인스턴스 변수) 값들을 초기화 시키기 위한 특별한 메소드<br>
객체 초기화의 다양성 제공

#### 4. **중첩 클래스(Nested Class, Inner Class)**
- 클래스 속 클래스
    
#### 5. **Initializer**
- **Static Initializer**
> static{ 실행문장 } : 클래스 메모리 로드시 자동실행 
- **Instance Initializer**
> { 실행문장 } : 객체 생성시 마다 자동실행 --> 생성자 때문에 잘 사용 안함
    
--- 

### 💡 클래스 작성

- 패키지 선언문 (0 or 1)
``` java
package top.sub....; 
// 물리적 : 폴더
// 보통 domain name(Unique!) 역순사용
```

- import문 (0 ~ 多) 
``` java
import top.sub...클래스이름; // 소스 클래스명 바로사용
import top.sub...*; // all classes, interfaces
(not package) : import단위는 패키지 아님!

현 클래스안에서 참조, 사용하는 클래스가 자신과 같은 패키지가 아닌 경우 명시
단, java.lang은 자동으로 불러옴
```

- class 정의 (1 ~ 多)
``` java
** []는 상황에 따라 생략가능함

* 클래스정의
[접근지정자] [활용지정자] class 클래스명 [extends 부모클래스명] [implements 부모인터페이스명,,,] { } 

// 접근지정자
(default),public

// 활용지정자
final : 상속금지
abstract : 추상클래스 (미완성클래스)

// 클래스명
명사형, 첫글자 대문자, 카멜표기법

// extends 
클래스 단일상속

// implements
인터페이스 다중상속



* 멤버정의
[접근지정자] [활용지정자] DataType 변수명 [=초기값];

// 접근지정자
public,protected,(default),private

// 활용지정자
static : 클래스멤버
final : 상수화, 생성자에서 초기화 필수
static final : 어차피 상수이기 때문에 static으로 사용
transient : 객체직렬화 대상제외

// 변수명
명사형, 첫글자 소문자, 카멜표기법

// 초기값
생략시 default값으로 초기화 (0, null, false)



* 메소드정의
[접근지정자] [활용지정자] returnType 메소드명 ([매개변수선언,,,]) [throws Exception명,,,] 
{
    실행문장 
    [return 리턴값]
}

// 접근지정자
public,protected,(default),private

// 활용지정자
static : 객체 생성없이 '클래스이름.메소드이름()'으로 호출 가능, 메소드 내에서 인스턴스 변수 사용 불가
final : 메소드 재정의 X
synchronized : 객체 동기화를 위한 잠금
abstract : 메소드 추상화

// return 리턴값
void : 없음 -> return문 생략가능
not void : return값 명시



* 생성자
[접근지정자] 클래스명 ([매개변수선언,,,]) [throws Exception명,,,] {}

// 접근지정자
public,protected,(default),private

```

### 💡 new 키워드

**객체를 생성할 때는 new 라는 키워드를 사용한다.**

new 키워드는 메모리상에 공간을 할당하고, 할당받은 공간의 주소값을 반환한다.

자바에서 Primitive Type을 제외한 타입 즉, Reference Type의 변수를 초기화 시키면 객체를 Heap 영역에 저장하고 레퍼런스 타입의 변수에는 new 키워드가 주소값을 가지고 Stack 영역에 저장된다.

new라는 키워드는 메모리상에 공간을 할당하고, 할당받은 공간을 주소를 리턴한다.


```java
// 클래스이름 참조변수 = new 생성자호출; -> 객체생성시 초기화를 담당하는 특별한 메소드
Person p1 = new Person("배문규", 29);
Person p2 = new Person("정다운", 29);
```
위 소스코드를 실행하면

1. Class Area에 Person 바이트코드가 올라감

2. new 키워드가 메모리상에 공간을 할당하여 Heap에 인스턴스 변수가 올림

3. new 키워드가 인스턴스변수의 메모리 주소를 리턴하여 Stack에 p1, p2 레퍼런스 변수를 저장해서 올림

![](https://user-images.githubusercontent.com/51703260/132106339-c2ffcdf1-54fc-46d7-982b-e44bece8a755.png)


--- 

### 💡 this 키워드

- non-static 영역(instance 메소드, 생성자, instance initializer)에서 사용함.
- 현재 생성중인, 실행중인 그 객체 자기자신을 일컫음.

**사용법**

#### 1. 지역변수와 인스턴스변수를 구분하기 위해서
```java
void setName(String name){
   this.name=name;
}
```

#### 2. 생성자가 오버로딩된 경우, 자신의 또 다른 생성자를 호출 시 this를 부를 수 있다.
```java
this();
```

#### 3. 자기 자신의 객체를 메소드의 매개변수로 전달하거나 리턴하기 위해서
```java
XXX(){
   return this; // 자기 자신을 리턴
}

YYY(){
   obj.zzz(this); // 자기 자신을 매개변수로 전달
}
```

---

### 💡 super 키워드

- this와 마찬가지로 non-static 영역(instance 메소드, 생성자, instance initializer)에서 사용함.
- 현재 생성중인, 실행중인 객체의 부모를 의미하도록 사용하는 논리적인 개념

**사용법**

#### 1. 자신의 메소드와 부모의 메소드를 구분하기 위해 사용(메소드 재정의 상황)

```java
this.XXX()
super.XXX()

// 참고로, 메소드 말고 멤버는 개념적으로 구분하지 않음
// 부모의 멤버는 자식에게도 있기 때문임
```

#### 2. 자식의 생성자에서 부모 생성자를 명시적으로 호출하기 위해 사용

```java
super();
```

this의 3번 개념은 super에 없다. (있을 필요가 없다.) 

--- 

## 추상 클래스

추상 클래스를 선언하는 방법은 class키워드 앞에 **abstract** 를 붙혀서 선언할 수 있다.

추상 클래스는 미완성 클래스로 new키워드로 다이렉트 객체 생성이 불가능하고 반드시 하위 클래스를 필요로한다. <br>대신 자식 객체의 참조변수로 사용가능하다.

인터페이스에서 선언할 수 없는 변수나 구현된 메소드를 포함시킬 때 사용한다.<br>
추상클래스는 결국 클래스이기 때문에 단일상속만 가능하다.<br>

추상 클래스는 2가지로 구분할 수 있다.

1. **추상 메소드가 없는 추상 클래스**
    - 해당 클래스의 객체생성을 막을 때 사용
    - 상속 받는 자식 클래스에서 개별적인 특성을 추가적으로 부여한 후 객체 생성

2. **추상 메소드가 있는 추상 클래스**
    - 해당 추상 클래스를 상속받는 자식 클래스에서 추상 메소드 오버라이딩 필수
    - 자식 클래스에게 추상 메서드의 오버라이딩 강제성을 부여하여 프로그램의 안정성을 향상
    - 추상 메소드가 존재하면 반드시 해당 클래스는 추상 클래스

참고로, 최상위 클래스를 상속받는 중간 클래스에서 최상위 클래스의 메소드를 추상메소드로 오버라이딩을 할 수 있다.<br>
최상위클래스에서 없던 의무성을 중간 클래스에서 아래로 부여할 수도 있다.

## 🇮🇳 인터페이스
### 💡 인터페이스 정의

인터페이스란, 어떠한 기능을 사용하기 위한 일종의 **표준(약속, 방법)** 이다. <br>인터페이스는 기능을 사용하는 **사용자 관점** 과 기능을 제공하는 **제공자 관점** 으로 구분할 수 있다.

**기능 사용자** 는 인터페이스를 통해 사용방법을 알 수 있으며, 인터페이스에 적혀 있는대로만 기능을 사용할 수 있다. <br>또한, 제공자가 어떻게 구현했는지에 대해 상세히 알 필요가 없어 결합도가 낮아지며 모듈화가 가능해진다. 

**기능 제공자** 는 이 기능들을 꼭 구현해야만 책임이 부여되지만 자신의 코드를 노출하지 않아도 된다는 장점을 가지고 있다.

- **사용자 관점 :** 사용방법, 약속    
- **제공자 관점 :** 구현의 책임

구현의 강제화로 서로 다른 모듈이 같은 인터페이스를 상속한다면 사용자들은 손쉽게 모듈 교체가 가능

서로 상속 관계가 없는 간접적인 클래스들에게 인터페이스를 통한 관계 부여로 다형성 확장 가능

--- 

### 💡 인터페이스 구현

클래스를 구현할 땐 class키워드를 사용했지만, 인터페이스는 interface라는 키워드를 사용한다.

```java
** []는 상황에 따라 생략가능함

* 인터페이스 정의
[접근지정자] interface 인터페이스명 [extends 부모 인터페이스명]{ } 

// 접근지정자
(default),public
// 클래스는 인터페이스를 상속받을 때 implements키워드를 사용하지만,
// 인터페이스가 인터페이스를 상속받을 때는 extends키워드를 사용한다.

interface 인터페이스명{
	// 1. 상수
	[public static final]타입 상수명 = 상수값;
	
	// 2. 추상 메소드
	[public abstract]타입 메소드명(매개변수);

	// 3. 디폴트 메소드
	default 타입 메소드명(매개변수){
		// 구현
	}

	// 4. 스태틱 메소드
	static 타입 메소드명(매개변수){
		// 구현
	}
}
```

**Java 8 이전까지**는 상수와 추상 메소드만 선언 가능하였지만, <br>
**Java 8 이후부터는** 디폴트 메소드와 스태틱 메소드가 추가되었다.

1. 상수 **(절대)** : 인터페이스에서 고정된 값만 제공.
2. 추상 메소드 **(강제)** : 인터페이스에서 **가이드**를 제공하고 상속받아 오버라이딩해서 구현.
3. 디폴트 메소드 **(선택)** : 인터페이스에서 구현 메소드 제공, **오버라이딩 가능**
4. 스태틱 메소드 **(절대)** : 인터페이스에서 구현 메소드 제공, **오버라이딩 불가**

근본적으로 추상 클래스는 클래스이므로 **"is-a : ~는 ~이다." 관계** 이기 때문에 단일 상속만 가능한 것이고,<br>
인터페이스는 클래스가 아니므로 **"has-a : ~는 ~를 할 수 있다." 관계** 이기 때문에 다중 상속이 가능한 것이다.

```java
// Baemung은 사람이며 움직일 수 있고, 들을 수 있고, 개발할 수 있다.
class Baemung extends Person implements Movable, Hearable, Developable 
```

#### 다형성은 조상클래스와 조상인터페이스 모두 적용 가능

```java
class IronMan implements Heroable, Fightable, Transformable {}

IronMan tony = new IronMan();
Object obj = tony;
Heroable hero = tony;
Fightable fighter = tony;
Transformable trans = tony;
```
